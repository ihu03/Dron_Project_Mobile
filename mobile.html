<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#050a17" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Seoul ADS-B Mobile</title>
  <link rel="stylesheet" href="./leaflet.css" />
  <style>
    :root {
      --bg: #0b1224;
      --panel: rgba(9, 14, 28, 0.75);
      --text: #e9f1ff;
      --muted: #9cb2d5;
      --accent: #38bdf8;
      --warn: #f59e0b;
      --danger: #f43f5e;
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      width: 100%;
      background: #050a17;
    }

    body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      color: var(--text);
      overflow: hidden;
    }

    #map {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #050a17;
    }

    /* Dim only the map tiles (not markers/UI) */
    .leaflet-tile-pane {
      filter: brightness(0.4);
    }

    .hud {
      position: fixed;
      top: calc(env(safe-area-inset-top, 0px) + 6px);
      left: calc(env(safe-area-inset-left, 0px) + 8px);
      right: calc(env(safe-area-inset-right, 0px) + 8px);
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      pointer-events: none;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 14px;
      background: var(--panel);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--text);
      font-weight: 700;
      font-size: 13px;
      pointer-events: auto;
      border: none;
      cursor: default;
    }

    .pill .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 0 6px rgba(56, 189, 248, 0.2);
    }

    .pill.warn .dot { background: var(--warn); box-shadow: 0 0 0 6px rgba(245, 158, 11, 0.25); }
    .pill.danger .dot { background: var(--danger); box-shadow: 0 0 0 6px rgba(244, 63, 94, 0.25); }

    .pill.muted {
      color: var(--muted);
    }

    .pill.action {
      cursor: pointer;
      background: rgba(56, 189, 248, 0.18);
      border: 1px solid rgba(56, 189, 248, 0.35);
      color: #d7ecff;
      transition: transform 0.1s ease, box-shadow 0.15s ease;
    }

    .pill.action:active {
      transform: translateY(1px);
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.25);
    }

    .alert-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 6px 10px;
      border-radius: 12px;
      background: rgba(244, 63, 94, 0.9);
      color: #ffe8ed;
      font-weight: 800;
      font-size: 12px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      pointer-events: none;
      box-shadow: 0 6px 12px rgba(244, 63, 94, 0.35);
    }

    .panel {
      position: fixed;
      bottom: calc(env(safe-area-inset-bottom, 0px) + 16px);
      left: calc(env(safe-area-inset-left, 0px) + 12px);
      right: calc(env(safe-area-inset-right, 0px) + 12px);
      padding: 12px 14px;
      border-radius: 18px;
      background: var(--panel);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 13px;
      pointer-events: auto;
      z-index: 30;
    }

    .panel strong { color: var(--text); }
    .panel span { color: var(--muted); }

    .panel .stat {
      display: grid;
      gap: 4px;
      min-width: 120px;
    }

    .btn-stat {
      width: 100%;
    }

    .btn {
      padding: 12px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: linear-gradient(180deg, rgba(40, 90, 180, 0.35), rgba(20, 60, 120, 0.6));
      color: #cde3ff;
      font-weight: 800;
      letter-spacing: -0.1px;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 8px 20px rgba(0, 0, 0, 0.25);
      cursor: pointer;
      width: 100%;
      transition: transform 0.1s ease, box-shadow 0.15s ease;
    }

    .btn:active {
      transform: translateY(1px);
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.25);
    }

    .btn.secondary {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.03));
      color: #d7e3f5;
      border-color: rgba(255, 255, 255, 0.08);
    }

    .btn.danger {
      background: linear-gradient(180deg, rgba(244, 63, 94, 0.3), rgba(148, 35, 52, 0.65));
      border-color: rgba(244, 63, 94, 0.35);
      color: #ffe4ea;
    }

    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .hidden {
      display: none !important;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      display: grid;
      place-items: center;
      z-index: 50;
      padding: 16px;
      backdrop-filter: blur(3px);
    }

    .modal__panel {
      width: min(420px, 100%);
      background: rgba(10, 20, 40, 0.94);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      padding: 14px 16px 16px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
      color: var(--text);
    }

    .modal__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .modal__title {
      font-weight: 800;
      font-size: 16px;
    }

    .modal__close {
      width: 32px;
      height: 32px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
      cursor: pointer;
    }

    .modal__body {
      display: grid;
      gap: 12px;
      margin-bottom: 12px;
    }

    .modal__field {
      display: grid;
      gap: 6px;
      font-size: 13px;
      color: var(--muted);
    }

    .modal__field input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text);
      font-size: 14px;
    }

    .modal__range-block {
      display: grid;
      grid-template-columns: 1fr 110px;
      gap: 10px;
      align-items: center;
    }

    .modal__range-block input[type="range"],
    .modal__range input[type="range"],
    .dual-range {
      --track-height: 10px;
      --track-bg: rgba(255, 255, 255, 0.08);
      --fill: 0%;
      --fill-gradient: linear-gradient(90deg, #3ecbff 0%, #1fa7ff 100%);
      --thumb-size: 18px;
    }

    .modal__range-block input[type="range"],
    .modal__range input[type="range"] {
      width: 100%;
      appearance: none;
      height: var(--track-height);
      border-radius: 999px;
      background: transparent;
      outline: none;
      box-shadow: none;
      accent-color: #3ecbff;
    }

    .modal__range-block input[type="range"]::-webkit-slider-runnable-track,
    .modal__range input[type="range"]::-webkit-slider-runnable-track {
      height: var(--track-height);
      border-radius: 999px;
      background:
        var(--fill-gradient) 0 / var(--fill) 100% no-repeat,
        var(--track-bg);
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(255, 255, 255, 0.04);
    }

    .modal__range-block input[type="range"]::-moz-range-track,
    .modal__range input[type="range"]::-moz-range-track {
      height: var(--track-height);
      border-radius: 999px;
      background: var(--track-bg);
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.35), 0 0 0 1px rgba(255, 255, 255, 0.04);
      border: none;
    }

    .modal__range-block input[type="range"]::-moz-range-progress,
    .modal__range input[type="range"]::-moz-range-progress {
      height: var(--track-height);
      border-radius: 999px;
      background: var(--fill-gradient);
      border: none;
    }

    .modal__range-block input[type="range"]::-webkit-slider-thumb,
    .modal__range input[type="range"]::-webkit-slider-thumb,
    .dual-range input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: var(--thumb-size);
      height: var(--thumb-size);
      border-radius: 50%;
      background: linear-gradient(180deg, #f8fbff, #d7ebff);
      border: 2px solid #7cd8ff;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35), 0 0 0 6px rgba(56, 189, 248, 0.15);
      cursor: pointer;
      margin-top: calc((var(--thumb-size) - var(--track-height)) / -2);
      transition: transform 0.1s ease, box-shadow 0.15s ease;
    }

    .modal__range-block input[type="range"]::-moz-range-thumb,
    .modal__range input[type="range"]::-moz-range-thumb,
    .dual-range input[type="range"]::-moz-range-thumb {
      width: var(--thumb-size);
      height: var(--thumb-size);
      border-radius: 50%;
      background: linear-gradient(180deg, #f8fbff, #d7ebff);
      border: 2px solid #7cd8ff;
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35), 0 0 0 6px rgba(56, 189, 248, 0.15);
      cursor: pointer;
      transition: transform 0.1s ease, box-shadow 0.15s ease;
    }

    .modal__range-block input[type="range"]:active::-webkit-slider-thumb,
    .modal__range input[type="range"]:active::-webkit-slider-thumb,
    .dual-range input[type="range"]:active::-webkit-slider-thumb {
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4), 0 0 0 8px rgba(56, 189, 248, 0.18);
      transform: translateY(1px);
    }

    .modal__range-block input[type="range"]:active::-moz-range-thumb,
    .modal__range input[type="range"]:active::-moz-range-thumb,
    .dual-range input[type="range"]:active::-moz-range-thumb {
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4), 0 0 0 8px rgba(56, 189, 248, 0.18);
      transform: translateY(1px);
    }

    .dual-range {
      position: relative;
      height: 48px;
      margin-bottom: 8px;
      padding: 10px 0;
    }

    .dual-range input[type="range"] {
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      background: transparent;
      pointer-events: none;
      height: var(--track-height);
    }

    .dual-range input[type="range"]::-webkit-slider-runnable-track {
      background: transparent;
      height: var(--track-height);
      border: none;
    }

    .dual-range input[type="range"]::-moz-range-track {
      background: transparent;
      height: var(--track-height);
      border: none;
    }

    .dual-range input[type="range"]::-webkit-slider-thumb {
      pointer-events: auto;
    }

    .dual-range input[type="range"]::-moz-range-thumb {
      pointer-events: auto;
    }

    .dual-range__track {
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      height: var(--track-height);
      border-radius: 999px;
      background: var(--track-bg);
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .dual-range__fill {
      position: absolute;
      height: var(--track-height);
      top: 50%;
      transform: translateY(-50%);
      border-radius: 999px;
      background: var(--fill-gradient);
      box-shadow: 0 8px 18px rgba(31, 167, 255, 0.25);
      pointer-events: none;
    }

    .modal__range {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: 8px;
      align-items: center;
    }

    .modal__range .dash {
      color: var(--muted);
      font-weight: 700;
    }

    .modal__actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .plane-popup .popup-body {
      display: grid;
      gap: 6px;
      color: var(--text);
    }

    .plane-popup .popup-title {
      font-weight: 800;
      font-size: 14px;
    }

    .plane-popup .popup-hex {
      color: var(--muted);
      font-size: 12px;
    }

    .plane-popup .popup-img img {
      width: 100%;
      max-height: 180px;
      object-fit: contain;
      border-radius: 8px;
      display: block;
    }

    .deny-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: grid;
      place-items: center;
      z-index: 999;
      padding: 16px;
      backdrop-filter: blur(4px);
    }

    .deny-panel {
      background: rgba(10, 20, 40, 0.94);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      padding: 16px;
      color: var(--text);
      max-width: 340px;
      text-align: center;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
    }

    .deny-title {
      font-weight: 800;
      margin-bottom: 6px;
    }

    .deny-desc {
      color: var(--muted);
      font-size: 14px;
      line-height: 1.4;
    }

    .perm-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.65);
      display: grid;
      place-items: center;
      z-index: 998;
      padding: 16px;
      backdrop-filter: blur(4px);
    }

    .perm-actions {
      margin-top: 12px;
    }

    /* Plane icons */
    .plane-icon {
      display: inline-block;
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.35));
      transform: translateZ(0);
      will-change: transform;
    }
    .plane-icon svg {
      display: block;
    }

    .error {
      position: fixed;
      top: 12px;
      right: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(244, 63, 94, 0.2);
      border: 1px solid rgba(244, 63, 94, 0.35);
      color: #ffdce5;
      font-weight: 700;
      display: none;
      backdrop-filter: blur(6px);
    }

    @media (max-width: 540px) {
      .panel {
        gap: 8px;
        font-size: 12px;
      }
      .pill {
        font-size: 12px;
      }
    }
  </style>
</head>
  <body>
  <div id="map"></div>
  <div class="hud">
    <div class="pill" id="status-pill">
      <span class="dot"></span>
      <span id="status-text">기체 불러오는 중...</span>
    </div>
    <span id="alert-indicator" class="alert-badge hidden">경고</span>
  </div>
  <div class="error" id="error-box"></div>
  <div class="panel">
    <div class="stat btn-stat" id="row-add-plane">
      <button id="add-plane" class="btn wide">기체 추가</button>
    </div>
    <div class="stat btn-stat hidden" id="row-config-plane">
      <button id="config-plane" class="btn secondary wide">기체 설정</button>
    </div>
    <div class="stat btn-stat hidden" id="row-delete-plane">
      <button id="delete-plane" class="btn danger wide">기체 삭제</button>
    </div>
  </div>

  <div id="deny-overlay" class="deny-overlay hidden" role="alert">
    <div class="deny-panel">
      <div class="deny-title">알림 권한이 거부되었습니다</div>
      <div class="deny-desc">알림을 수신할 수 없어 기능이 제한됩니다. 권한을 허용해 주세요.</div>
    </div>
  </div>

  <div id="perm-overlay" class="perm-overlay hidden" role="dialog" aria-modal="true">
    <div class="deny-panel">
      <div class="deny-title">알림 권한이 필요합니다</div>
      <div class="deny-desc">안전 반경 침입 알림을 받기 위해 알림을 허용해 주세요.</div>
      <div class="perm-actions">
        <button id="perm-accept" class="btn wide">알림 허용</button>
      </div>
    </div>
  </div>

  <div class="modal hidden" id="config-modal" role="dialog" aria-modal="true">
    <div class="modal__panel">
      <div class="modal__header">
        <div class="modal__title">기체 설정</div>
        <button type="button" class="modal__close" id="config-close" aria-label="닫기">×</button>
      </div>
      <div class="modal__body">
        <label class="modal__field">
          <span>레이더 반경 (km)</span>
          <div class="modal__range-block">
            <input type="range" id="cfg-radar-range" min="1" max="400" step="1" value="10" />
            <input type="number" id="cfg-radar" min="1" max="400" step="1" value="10" inputmode="numeric" />
          </div>
        </label>
        <label class="modal__field">
          <span>안전 반경 (km)</span>
          <div class="modal__range-block">
            <input type="range" id="cfg-safety-range" min="1" max="200" step="1" value="5" />
            <input type="number" id="cfg-safety" min="1" max="200" step="1" value="5" inputmode="numeric" />
          </div>
        </label>
        <label class="modal__field">
          <span>고도 허용 범위 (km)</span>
          <div class="modal__range-block">
            <input type="range" id="cfg-alt-range" min="0" max="20" step="0.1" value="6" />
            <input type="number" id="cfg-alt" min="0" max="20" step="0.1" value="6" inputmode="decimal" />
          </div>
        </label>
      </div>
      <div class="modal__actions">
        <button type="button" class="btn secondary" id="config-cancel">취소</button>
        <button type="button" class="btn" id="config-save">저장</button>
      </div>
    </div>
  </div>

  <script src="./leaflet.js"></script>
  <script>
    const map = L.map("map", { worldCopyJump: true, zoomControl: false }).setView([37.5665, 126.9780], 8);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 18,
      attribution: "(c) OpenStreetMap contributors",
    }).addTo(map);
    map.attributionControl.setPrefix("");

    const statusPill = document.getElementById("status-pill");
    const statusText = document.getElementById("status-text");
    const alertIndicator = document.getElementById("alert-indicator");
    const errorBox = document.getElementById("error-box");
    const countTotal = document.getElementById("count-total");
    const countPos = document.getElementById("count-pos");
    const pingMs = document.getElementById("ping-ms");
    const permOverlay = document.getElementById("perm-overlay");
    const permAccept = document.getElementById("perm-accept");
    permAccept?.addEventListener("click", () => ensurePushActive(true));

    const setRangeFill = (input) => {
      if (!input) return;
      const min = parseFloat(input.min || "0");
      const max = parseFloat(input.max || "100");
      const val = parseFloat(input.value || min);
      const pct = Math.min(Math.max(((val - min) / Math.max(max - min, 0.0001)) * 100, 0), 100);
      input.style.setProperty("--fill", `${pct}%`);
    };

    // ?щ씪?대뜑? ?レ옄 ?낅젰 ?숆린??+ 梨꾩썙吏?援ш컙 ?ㅽ???媛깆떊
    const syncRange = (rangeId, numberId, setter) => {
      const r = document.getElementById(rangeId);
      const n = document.getElementById(numberId);
      if (!r || !n) return;
      const apply = (val) => {
        const num = parseFloat(val);
        if (Number.isFinite(num)) {
          n.value = num;
          if (typeof setter === "function") setter(num);
          setRangeFill(r);
        }
      };
      setRangeFill(r);
      r.addEventListener("input", () => apply(r.value));
      n.addEventListener("input", () => apply(n.value));
    };

    syncRange("cfg-radar-range", "cfg-radar", (v) => (manualConfig.radarKm = Math.max(1, v)));
    syncRange("cfg-safety-range", "cfg-safety", (v) => (manualConfig.safetyKm = Math.max(1, v)));

    const altRange = document.getElementById("cfg-alt-range");
    const altInput = document.getElementById("cfg-alt");

    const syncAltSingle = () => {
      if (!altRange || !altInput) return;
      const apply = (val) => {
        const num = parseFloat(val);
        if (!Number.isFinite(num)) return;
        manualConfig.altMinKm = 0;
        manualConfig.altMaxKm = Math.max(0, Math.min(num, 20));
        altRange.value = manualConfig.altMaxKm;
        altInput.value = manualConfig.altMaxKm;
        setRangeFill(altRange);
      };
      setRangeFill(altRange);
      altRange.addEventListener("input", () => apply(altRange.value));
      altInput.addEventListener("input", () => apply(altInput.value));
    };

    syncAltSingle();

    const markers = new Map(); // hex -> { marker, lastSeen }
    const trails = new Map(); // hex -> LatLng[]
    const trailLines = new Map(); // hex -> polyline
    let selectedTrailHex = null;
    const STALE_MS = 45000;
    const POLL_MS = 2000;
    const VAPID_PUBLIC_KEY_ENDPOINT = "/vapid-public-key";
    let swRegistration = null;
    let manualPlane = null;
    const MANUAL_HEX = "FAKE-LOCAL";
    const manualConfig = {
      radarKm: 10,
      safetyKm: 5,
      altMinKm: 0,
      altMaxKm: 6,
    };
    let dangerActive = false;
    let lastDangerNotified = 0;
    const DANGER_COOLDOWN_MS = 15000;
    const notifiedSafetyHexes = new Set();
    let radarCircle = null;
    let safetyCircle = null;
    let sectorCone = null;
    let sectorBearing = null;
    const imageCache = new Map(); // hex -> { status, url }

    const FT_TO_M = 0.3048;

    function altitudeMeters(ac) {
      const ft = Number.isFinite(ac?.alt_baro) ? ac.alt_baro : null;
      return ft === null ? null : ft * FT_TO_M;
    }

    function hexToRgb(hex) {
      const v = hex.replace("#", "");
      return [parseInt(v.slice(0, 2), 16), parseInt(v.slice(2, 4), 16), parseInt(v.slice(4, 6), 16)];
    }

    function lerpColor(a, b, t) {
      const clamped = Math.min(Math.max(t, 0), 1);
      const [ar, ag, ab] = hexToRgb(a);
      const [br, bg, bb] = hexToRgb(b);
      const rr = Math.round(ar + (br - ar) * clamped);
      const rg = Math.round(ag + (bg - ag) * clamped);
      const rb = Math.round(ab + (bb - ab) * clamped);
      return `#${rr.toString(16).padStart(2, "0")}${rg.toString(16).padStart(2, "0")}${rb.toString(16).padStart(2, "0")}`;
    }

    function adjustColor(hex, t = 0) {
      const [r, g, b] = hexToRgb(hex);
      const clamp = (v) => Math.min(255, Math.max(0, Math.round(v)));
      const mix = (ch) => (t >= 0 ? ch + (255 - ch) * t : ch * (1 + t));
      return `#${clamp(mix(r)).toString(16).padStart(2, "0")}${clamp(mix(g)).toString(16).padStart(2, "0")}${clamp(mix(b)).toString(16).padStart(2, "0")}`;
    }

    function destinationPoint(lat, lon, bearingDegVal, distanceKm) {
      const R = 6371;
      const delta = distanceKm / R;
      const theta = (bearingDegVal * Math.PI) / 180;
      const lat1 = (lat * Math.PI) / 180;
      const lon1 = (lon * Math.PI) / 180;

      const sinLat1 = Math.sin(lat1);
      const cosLat1 = Math.cos(lat1);
      const sinDelta = Math.sin(delta);
      const cosDelta = Math.cos(delta);
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);

      const sinLat2 = sinLat1 * cosDelta + cosLat1 * sinDelta * cosTheta;
      const lat2 = Math.asin(sinLat2);
      const y = sinTheta * sinDelta * cosLat1;
      const x = cosDelta - sinLat1 * sinLat2;
      const lon2 = lon1 + Math.atan2(y, x);

      return [(lat2 * 180) / Math.PI, ((lon2 * 180) / Math.PI + 540) % 360 - 180];
    }

    function bearingDeg(lat1, lon1, lat2, lon2) {
      const toRad = (d) => (d * Math.PI) / 180;
      const toDeg = (r) => (r * 180) / Math.PI;
      const phi1 = toRad(lat1);
      const phi2 = toRad(lat2);
      const dLon = toRad(lon2 - lon1);
      const y = Math.sin(dLon) * Math.cos(phi2);
      const x = Math.cos(phi1) * Math.sin(phi2) - Math.sin(phi1) * Math.cos(phi2) * Math.cos(dLon);
      const theta = Math.atan2(y, x);
      return (toDeg(theta) + 360) % 360;
    }

    function altitudeToColor(ac) {
      const altM = Math.max(0, Number.isFinite(altitudeMeters(ac)) ? altitudeMeters(ac) : 0);
      const bands = [
        { max: 2000, from: adjustColor("#00A8FF", -0.15), to: adjustColor("#00A8FF", 0.25) },
        { max: 8000, from: adjustColor("#22C55E", -0.15), to: adjustColor("#22C55E", 0.25) },
        { max: Infinity, from: adjustColor("#A855F7", -0.15), to: adjustColor("#A855F7", 0.25) },
      ];
      let prevMax = 0;
      for (const band of bands) {
        if (altM <= band.max) {
          const range = band.max - prevMax;
          const t = !Number.isFinite(range) ? 0 : (altM - prevMax) / Math.max(range, 1);
          return lerpColor(band.from, band.to, t);
        }
        prevMax = band.max;
      }
      return bands[bands.length - 1].to;
    }

    function createPlaneIcon(ac, isSelected = false, overrideColor = null) {
      const heading = Number.isFinite(ac.track) ? ac.track : 0;
      const color = overrideColor || altitudeToColor(ac);
      const outline = isSelected ? "rgba(0,0,0,0.45)" : "none";
      return L.divIcon({
        className: "plane-icon",
        iconSize: [32, 32],
        iconAnchor: [16, 16],
        html: `<svg viewBox="0 0 24 24" width="28" height="28" style="transform: rotate(${heading}deg); color:${color};" fill="currentColor">
          <circle cx="5" cy="5" r="2.4" fill="none" stroke="currentColor" stroke-width="1.6" opacity="0.82" />
          <circle cx="19" cy="5" r="2.4" fill="none" stroke="currentColor" stroke-width="1.6" opacity="0.82" />
          <circle cx="5" cy="19" r="2.4" fill="none" stroke="currentColor" stroke-width="1.6" opacity="0.82" />
          <circle cx="19" cy="19" r="2.4" fill="none" stroke="currentColor" stroke-width="1.6" opacity="0.82" />
          <path d="M11.25 3c0-.7.55-1.25 1.25-1.25S13.75 2.3 13.75 3v3.2l1.7-1.7a1 1 0 0 1 1.4 1.4L14.5 8.3H17c.7 0 1.25.55 1.25 1.25S17.7 10.8 17 10.8h-2.5l1.7 1.7a1 1 0 1 1-1.4 1.4L13.75 12V15c0 .7-.55 1.25-1.25 1.25S11.25 15.7 11.25 15V12l-1.7 1.7a1 1 0 0 1-1.4-1.4l1.7-1.7H7c-.7 0-1.25-.55-1.25-1.25S6.3 8.3 7 8.3h2.5L7.8 5.9a1 1 0 0 1 1.4-1.4l2.05 2.05z" stroke="${outline}" stroke-width="1.2" stroke-linejoin="round" />
          <path d="M12 4.3 13.2 6.5h-2.4L12 4.3z" />
          <circle cx="12" cy="12" r="2.2" />
        </svg>`
      });
    }

    function formatTime() {
      const now = new Date();
      return now.toLocaleTimeString("ko-KR", { hour12: false });
    }

    function setStatus(text, tone = "ok") {
      statusText.textContent = text;
      statusPill.classList.remove("warn", "danger");
      if (tone === "warn") statusPill.classList.add("warn");
      if (tone === "danger") statusPill.classList.add("danger");
    }

    function showError(msg) {
      errorBox.textContent = msg;
      errorBox.style.display = "block";
      setTimeout(() => (errorBox.style.display = "none"), 4000);
    }

    function haversineKm(lat1, lon1, lat2, lon2) {
      const toRad = (d) => (d * Math.PI) / 180;
      const R = 6371;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function updateMarkers(list) {
      const now = Date.now();
      const seen = new Set();

      list.forEach((ac) => {
        if (!Number.isFinite(ac.lat) || !Number.isFinite(ac.lon)) return;
        const hex = ac.hex || ac.icao || ac.id || Math.random().toString(16).slice(2, 8);
        const pos = [ac.lat, ac.lon];
        seen.add(hex);

        let overrideColor = null;
        if (manualPlane) {
        const distKm = haversineKm(manualPlane.lat, manualPlane.lon, ac.lat, ac.lon);
        const altM = altitudeMeters(ac);
        const withinAlt = altM === null || (altM >= manualConfig.altMinKm * 1000 && altM <= manualConfig.altMaxKm * 1000);
        if (distKm <= manualConfig.safetyKm && withinAlt) {
          overrideColor = "#f43f5e"; // red
        } else if (distKm <= manualConfig.radarKm) {
          overrideColor = "#facc15"; // yellow
        }
        }

        const clickHandler = () => openPlaneDetail(ac, pos);

        if (!markers.has(hex)) {
          const marker = L.marker(pos, { icon: createPlaneIcon(ac, false, overrideColor) }).addTo(map);
          marker.bindTooltip(`${ac.flight || ac.hex || "Unknown"}`, { direction: "top", offset: [0, -8] });
          marker.on("click", clickHandler);
          markers.set(hex, { marker, lastSeen: now });
        } else {
          const entry = markers.get(hex);
          entry.marker.setLatLng(pos);
          entry.marker.setIcon(createPlaneIcon(ac, false, overrideColor));
          entry.lastSeen = now;
          entry.marker.off("click");
          entry.marker.on("click", clickHandler);
        }

        if (selectedTrailHex === hex) {
          const history = trails.get(hex) || [];
          history.push(pos);
          if (history.length > 150) history.shift();
          trails.set(hex, history);
          if (!trailLines.has(hex)) {
            const line = L.polyline(history, { color: overrideColor || altitudeToColor(ac), weight: 2, opacity: 0.4 }).addTo(map);
            trailLines.set(hex, line);
          } else {
            const line = trailLines.get(hex);
            line.setLatLngs(history);
            line.setStyle({ color: overrideColor || altitudeToColor(ac) });
          }
        }
      });

      // Remove stale markers
      markers.forEach((entry, hex) => {
        if (entry.manual) return;
        if (!seen.has(hex) && now - entry.lastSeen > STALE_MS) {
          map.removeLayer(entry.marker);
          markers.delete(hex);
          if (trailLines.has(hex)) {
            map.removeLayer(trailLines.get(hex));
            trailLines.delete(hex);
            trails.delete(hex);
            if (selectedTrailHex === hex) selectedTrailHex = null;
          }
        }
      });
    }

    function checkSafety(withPos = []) {
      if (!manualPlane) {
        dangerActive = false;
        alertIndicator?.classList.add("hidden");
        notifiedSafetyHexes.clear();
        return;
      }
      const hits = [];
      withPos.forEach((ac) => {
        if (!ac) return;
        const hexNorm = (ac.hex || ac.icao || ac.id || "").toUpperCase();
        if (!hexNorm || hexNorm === MANUAL_HEX) return;
        if (!Number.isFinite(ac.lat) || !Number.isFinite(ac.lon)) return;
        const distKm = haversineKm(manualPlane.lat, manualPlane.lon, ac.lat, ac.lon);
        const altM = altitudeMeters(ac);
        if (
          distKm <= manualConfig.safetyKm &&
          (altM === null || (altM >= manualConfig.altMinKm * 1000 && altM <= manualConfig.altMaxKm * 1000))
        ) {
          hits.push({ ac, distKm, hexNorm });
        }
      });

      dangerActive = hits.length > 0;
      if (alertIndicator) alertIndicator.classList.toggle("hidden", !dangerActive);

      if (dangerActive) {
        const closest = hits.sort((a, b) => a.distKm - b.distKm)[0];
        sectorBearing = bearingDeg(manualPlane.lat, manualPlane.lon, closest.ac.lat, closest.ac.lon);
        setStatus(`위험: 안전 반경 내 기체 감지 (${closest.distKm.toFixed(1)}km)`, "danger");
        updateManualOverlays();
        const newHits = hits.filter((h) => !notifiedSafetyHexes.has(h.hexNorm));
        newHits.forEach((h) => notifiedSafetyHexes.add(h.hexNorm));
        if (newHits.length && Date.now() - lastDangerNotified > DANGER_COOLDOWN_MS) {
          sendSafetyPush(newHits);
          try {
            if ("Notification" in window && Notification.permission === "granted") {
              const title = `안전반경 침입: ${newHits.length}대`;
              const body = newHits
                .slice(0, 3)
                .map((h) => `${h.ac.flight || h.ac.hex || "unknown"} (${h.distKm.toFixed(1)}km)`)
                .join(", ");
            if (swRegistration && swRegistration.showNotification) {
              swRegistration.showNotification(title, { body, icon: "/icons/icon-192.png", badge: "/icons/icon-192.png" });
            } else {
              new Notification(title, { body, icon: "/icons/icon-192.png", badge: "/icons/icon-192.png" });
              }
            }
          } catch (e) {
            /* ignore */
          }
          lastDangerNotified = Date.now();
        }
      } else {
        sectorBearing = null;
        updateManualOverlays();
      }
    }

    async function poll() {
      const start = performance.now();
      try {
        const res = await fetch("/api/aircraft", { cache: "no-store" });
        const elapsed = Math.max(1, Math.round(performance.now() - start));
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        const list = Array.isArray(data?.aircraft) ? data.aircraft : Array.isArray(data) ? data : [];
        const withPos = list.filter((p) => Number.isFinite(p.lat) && Number.isFinite(p.lon));

        if (countTotal) countTotal.textContent = list.length.toLocaleString("ko-KR");
        if (countPos) countPos.textContent = withPos.length.toLocaleString("ko-KR");
        if (pingMs) pingMs.textContent = `${elapsed} ms`;
        setStatus(withPos.length ? `기체 ${withPos.length.toLocaleString("ko-KR")}대 위치 표시 중` : "표시할 기체 없음", withPos.length ? "ok" : "warn");

        updateMarkers(withPos);
        checkSafety(withPos);
      } catch (e) {
        showError("데이터 불러오기 실패");
        setStatus("데이터 불러오기 실패", "danger");
      } finally {
        setTimeout(poll, POLL_MS);
      }
    }

    poll();

    function urlBase64ToUint8Array(base64String) {
      const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
      const base64 = (base64String + padding).replace(/-/g, "+").replace(/_/g, "/");
      const rawData = atob(base64);
      const outputArray = new Uint8Array(rawData.length);
      for (let i = 0; i < rawData.length; i++) {
        outputArray[i] = rawData.charCodeAt(i);
      }
      return outputArray;
    }

    async function registerServiceWorker() {
      if (!("serviceWorker" in navigator)) {
        showError("\uC774 \uBE0C\uB77C\uC6B0\uC800\uB294 \uC11C\uBE44\uC2A4 \uC6CC\uCEE4\uB97C \uC9C0\uC6D0\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.");
        return null;
      }
      if (swRegistration) return swRegistration;
      try {
        swRegistration = await navigator.serviceWorker.register("/sw.js");
        swRegistration = await navigator.serviceWorker.ready;
        return swRegistration;
      } catch (e) {
        showError("\uC11C\uBE44\uC2A4 \uC6CC\uCEE4 \uB4F1\uB85D \uC2E4\uD328");
        return null;
      }
    }

    async function ensurePushActive(interactive = false) {
      const reg = await registerServiceWorker();
      if (!reg) return false;
      if (!("Notification" in window) || !("PushManager" in window)) {
        showError("이 브라우저는 알림/푸시를 지원하지 않습니다.");
        return false;
      }
      const permission = Notification.permission;
      if (permission === "default" && !interactive) {
        showPermissionPrompt();
        return false;
      }
      const finalPermission = permission === "granted" ? "granted" : await Notification.requestPermission();
      if (finalPermission !== "granted") {
        showError("알림 권한 거부됨");
        showPermissionDenied();
        return false;
      }
      hidePermissionPrompt();

      let subscription = await reg.pushManager.getSubscription();
      try {
        if (!subscription) {
          const res = await fetch(VAPID_PUBLIC_KEY_ENDPOINT, { cache: "no-store" });
          if (!res.ok) throw new Error("VAPID ??遺덈윭?ㅺ린 ?ㅽ뙣");
          const vapidKey = (await res.text()).trim();
          const appServerKey = urlBase64ToUint8Array(vapidKey);
          subscription = await reg.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: appServerKey });
        }
        await fetch("/api/subscriptions", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ subscription }),
        });
        return true;
      } catch (e) {
        showError("?몄떆 ?쒖꽦???ㅽ뙣");
        return false;
      }
    }

    function showPermissionPrompt() {
      permOverlay?.classList.remove("hidden");
    }

    function hidePermissionPrompt() {
      permOverlay?.classList.add("hidden");
    }

    // ??吏꾩엯 ????踰?沅뚰븳/?몄떆 援щ룆 ?쒕룄 (?꾩슂 ???ㅻ쾭?덉씠 ?몄텧)
    ensurePushActive(false);

    function updateManualButtonsState() {
      const hasManual = Boolean(manualPlane && markers.has(MANUAL_HEX));
      const rowAdd = document.getElementById("row-add-plane");
      const rowConfig = document.getElementById("row-config-plane");
      const rowDelete = document.getElementById("row-delete-plane");
      if (hasManual) {
        rowAdd?.classList.add("hidden");
        rowConfig?.classList.remove("hidden");
        rowDelete?.classList.remove("hidden");
      } else {
        rowAdd?.classList.remove("hidden");
        rowConfig?.classList.add("hidden");
        rowDelete?.classList.add("hidden");
      }
    }

    function createManualPlane() {
      const center = map.getCenter();
      const ac = {
        hex: MANUAL_HEX,
        flight: "MANUAL",
        lat: center.lat,
        lon: center.lng,
        alt_baro: 12000, // ft
        track: 0,
      };
      const marker = L.marker([ac.lat, ac.lon], { icon: createPlaneIcon(ac, true), draggable: true }).addTo(map);
      marker.setZIndexOffset(1000);
      marker.bindTooltip("수동 추가 기체", { direction: "top", offset: [0, -8] });
      marker.on("dragend", (evt) => {
        const ll = evt.target.getLatLng();
        manualPlane.lat = ll.lat;
        manualPlane.lon = ll.lng;
        markers.set(MANUAL_HEX, { marker, lastSeen: Date.now(), manual: true });
        updateManualOverlays();
        setStatus("수동 기체 위치 변경됨", "ok");
      });
      markers.set(MANUAL_HEX, { marker, lastSeen: Date.now(), manual: true });
      manualPlane = ac;
      map.panTo(center);
      sectorBearing = null;
      setStatus("수동 기체 추가됨", "ok");
      updateManualOverlays();
      updateManualButtonsState();
    }

    function removeManualPlane() {
      const entry = markers.get(MANUAL_HEX);
      if (entry) {
        map.removeLayer(entry.marker);
        markers.delete(MANUAL_HEX);
        if (trailLines.has(MANUAL_HEX)) {
          map.removeLayer(trailLines.get(MANUAL_HEX));
          trailLines.delete(MANUAL_HEX);
          trails.delete(MANUAL_HEX);
        }
      }
      manualPlane = null;
      if (radarCircle) { map.removeLayer(radarCircle); radarCircle = null; }
      if (safetyCircle) { map.removeLayer(safetyCircle); safetyCircle = null; }
      if (sectorCone) { map.removeLayer(sectorCone); sectorCone = null; }
      setStatus("수동 기체 삭제됨", "warn");
      notifiedSafetyHexes.clear();
      updateManualButtonsState();
    }

    document.getElementById("add-plane")?.addEventListener("click", () => {
      removeManualPlane();
      createManualPlane();
    });

    document.getElementById("delete-plane")?.addEventListener("click", removeManualPlane);

    document.getElementById("config-plane")?.addEventListener("click", () => {
      const modal = document.getElementById("config-modal");
      if (modal) modal.classList.remove("hidden");
      const radar = document.getElementById("cfg-radar");
      const safety = document.getElementById("cfg-safety");
      const alt = document.getElementById("cfg-alt");
      if (radar) radar.value = manualConfig.radarKm;
      const radarRange = document.getElementById("cfg-radar-range");
      if (radarRange) {
        radarRange.value = manualConfig.radarKm;
        setRangeFill(radarRange);
      }
      if (safety) safety.value = manualConfig.safetyKm;
      const safetyRange = document.getElementById("cfg-safety-range");
      if (safetyRange) {
        safetyRange.value = manualConfig.safetyKm;
        setRangeFill(safetyRange);
      }
      if (alt) alt.value = manualConfig.altMaxKm;
      const altRange = document.getElementById("cfg-alt-range");
      if (altRange) {
        altRange.value = manualConfig.altMaxKm;
        setRangeFill(altRange);
      }
    });

    updateManualButtonsState();

    function closeConfigModal() {
      const modal = document.getElementById("config-modal");
      if (modal) modal.classList.add("hidden");
    }

    function saveConfig() {
      const radar = document.getElementById("cfg-radar");
      const safety = document.getElementById("cfg-safety");
      const alt = document.getElementById("cfg-alt");
      const radarRange = document.getElementById("cfg-radar-range");
      const safetyRange = document.getElementById("cfg-safety-range");
      const altRange = document.getElementById("cfg-alt-range");
      const toNumber = (el, fallback) => {
        if (!el) return fallback;
        const v = parseFloat(el.value);
        return Number.isFinite(v) ? v : fallback;
      };
      manualConfig.radarKm = Math.max(1, toNumber(radar, manualConfig.radarKm));
      manualConfig.safetyKm = Math.max(1, toNumber(safety, manualConfig.safetyKm));
      const maxVal = toNumber(alt, manualConfig.altMaxKm);
      manualConfig.altMinKm = 0;
      manualConfig.altMaxKm = Math.max(0, Math.min(maxVal, 20));
      if (radarRange) {
        radarRange.value = manualConfig.radarKm;
        setRangeFill(radarRange);
      }
      if (safetyRange) {
        safetyRange.value = manualConfig.safetyKm;
        setRangeFill(safetyRange);
      }
      if (altRange) {
        altRange.value = manualConfig.altMaxKm;
        setRangeFill(altRange);
      }
      if (alt) alt.value = manualConfig.altMaxKm;
      setStatus("설정이 저장되었습니다.", "ok");
      updateManualOverlays();
      closeConfigModal();
    }

    document.getElementById("config-close")?.addEventListener("click", closeConfigModal);
    document.getElementById("config-cancel")?.addEventListener("click", closeConfigModal);
    document.getElementById("config-save")?.addEventListener("click", saveConfig);

    async function sendSafetyPush(hits = []) {
      if (!hits.length) return;
      const ready = await ensurePushActive();
      if (!ready) return;
      try {
        await fetch("/api/push/safety", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            entries: hits.slice(0, 10).map((h) => ({
              hex: h.hexNorm || h.ac.hex,
              call: h.ac.flight || h.ac.hex || "unknown",
              dist: h.distKm,
              msg: `${h.ac.flight || h.ac.hex || "unknown"} (${h.distKm.toFixed(1)}km)`,
            })),
          }),
        });
      } catch (e) {
        /* ignore */
      }
    }

    function showPermissionDenied() {
      const overlay = document.getElementById("deny-overlay");
      overlay?.classList.remove("hidden");
      // ?쒕룄: 釉뚮씪?곗?媛 ?덉슜?섎㈃ 李??リ린
      try {
        window.close();
      } catch (e) {
        /* ignore */
      }
    }

    permAccept?.addEventListener("click", () => {
      ensurePushActive(true);
    });

    async function openPlaneDetail(ac, pos = null) {
      if (!ac?.hex) return;
      setTrailTarget(ac.hex, ac, pos || [ac.lat, ac.lon]);
      const hex = (ac.hex || "").toUpperCase();
      const name = ac.flight || hex || "Unknown";
      const popup = L.popup({ maxWidth: 260, minWidth: 200, className: "plane-popup" });
      popup.setLatLng(pos || [ac.lat, ac.lon]);
      popup.setContent(`<div class="popup-body"><div class="popup-title">${name}</div><div class="popup-hex">HEX: ${hex}</div><div id="popup-img-${hex}" class="popup-img">이미지 불러오는 중...</div></div>`);
      popup.openOn(map);

      if (imageCache.has(hex) && imageCache.get(hex).status === "ok") {
        const url = imageCache.get(hex).url;
        const imgEl = document.getElementById(`popup-img-${hex}`);
        if (imgEl) imgEl.innerHTML = `<img src="${url}" alt="${name}" />`;
        return;
      }

      try {
        const res = await fetch(`/api/plane-image?hex=${hex}`);
        if (!res.ok) throw new Error("image fetch failed");
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        imageCache.set(hex, { status: "ok", url });
        const imgEl = document.getElementById(`popup-img-${hex}`);
        if (imgEl) imgEl.innerHTML = `<img src="${url}" alt="${name}" />`;
      } catch (e) {
        imageCache.set(hex, { status: "fail" });
        const imgEl = document.getElementById(`popup-img-${hex}`);
        if (imgEl) imgEl.textContent = "이미지를 불러오지 못했습니다.";
      }
    }

    function setTrailTarget(hex, ac, pos) {
      if (selectedTrailHex && selectedTrailHex !== hex) {
        // clear previous trail line
        if (trailLines.has(selectedTrailHex)) {
          map.removeLayer(trailLines.get(selectedTrailHex));
          trailLines.delete(selectedTrailHex);
        }
        trails.delete(selectedTrailHex);
      }
      selectedTrailHex = hex;
      if (!trails.has(hex) && pos) {
        trails.set(hex, [pos]);
      }
    }

    function updateManualOverlays() {
      if (!manualPlane) return;
      const center = [manualPlane.lat, manualPlane.lon];
      if (!radarCircle) {
        radarCircle = L.circle(center, {
          radius: manualConfig.radarKm * 1000,
          color: "rgba(56, 189, 248, 0.8)",
          weight: 1.2,
          fillOpacity: 0.0,
        }).addTo(map);
      } else {
        radarCircle.setLatLng(center);
        radarCircle.setRadius(manualConfig.radarKm * 1000);
      }

      if (!safetyCircle) {
        safetyCircle = L.circle(center, {
          radius: manualConfig.safetyKm * 1000,
          color: "rgba(244, 63, 94, 0.8)",
          weight: 1.6,
          fillColor: "rgba(244, 63, 94, 0.15)",
          fillOpacity: 0.15,
        }).addTo(map);
      } else {
        safetyCircle.setLatLng(center);
        safetyCircle.setRadius(manualConfig.safetyKm * 1000);
      }

      const heading = sectorBearing ?? 0;
      const spreadDeg = 40;
      const start = heading - spreadDeg / 2;
      const end = heading + spreadDeg / 2;
      const steps = 10;
      const pts = [];
      pts.push(center);
      for (let i = 0; i <= steps; i++) {
        const b = start + ((end - start) * i) / steps;
        pts.push(destinationPoint(center[0], center[1], b, manualConfig.safetyKm));
      }
      const conePts = sectorBearing === null ? [] : pts;
      if (!sectorCone) {
        sectorCone = L.polygon(conePts, {
          color: "rgba(0,0,0,0)",
          weight: 0,
          fillColor: "rgba(244, 63, 94, 0.35)",
          fillOpacity: 0.35,
        }).addTo(map);
      } else {
        sectorCone.setLatLngs(conePts);
      }
      if (sectorBearing === null) {
        sectorCone.setStyle({ opacity: 0, fillOpacity: 0 });
      } else {
        sectorCone.setStyle({ opacity: 1, fillOpacity: 0.35 });
      }
    }
  </script>
</body>
</html>
